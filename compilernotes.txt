example parser tree:
		E
	E	=	E
	|		|
	id		id
The parser will take the tokens and create a parse tree from it
the parser tree only need to be read from left to right
at the leaf nodes
production: the rhs of a rule for example S -> aSb /e, aSb and e
are 2 productions
context free grammar if the lhs only have one non terminal
(not a token received from the lexer (expression etc.))

Left most derivation (LMD):
S -> aS|Sa|a -> S can be replaced with 3 different things
and in LMD the parser will choose the leftmost production
(here it's aS)
In Right Most Derivation (RMD) the parser will choose the
rightmost production(here it's a)

If each rule only have at most one non terminal(S in the example)
or the grammar is unambiogous then LMD = RMD

A grammar is ambiogous if more than one parse tree can be
constructed from the same input

Recursive Grammar:
If at least one rule has the same non terminal in both LHS
and RHS (i.e. S -> aSb | S)
Recursive grammar will always generate infinite strings
(ab,aabb,aaabbb, ...)

Non-Recursive Grammar:
If no rule has the same non terminal in both LHS and RHS
(i.e. S -> a | b)
It will always generate finite number of strins


Left Recursive Grammar (LRG):
If the LHS exists in the first part of a RHS production
(i.e. S -> Sb | b) (S -> bS | b is not left recursive)

Right Recursive Grammar (RRG):
If the LHS exists in the last part of a RHS production
(i.e. S -> bS | b) (S -> Sb | b is not right recursive)

General Recursive Grammar (GRG):
If the LHS exists in a RHS production but not in the first or
last position
(i.e. S -> aSb | c)

There are 2 types of recursion:

Direct Recursion: LRG, RRG, GRG
Indirect Recursion: LRG, RRG, GRG

Direct example: S -> Sa | b
Indirect example: S -> Aa, A -> Sb
(S wont derive to itself directly but through A)

Convert Left Recursion Grammars to Right Recursion Grammar:
Introduce a temporary variables
A -> Aa | B	(Left Recursion)

A -> BA'
A' -> aA' | €	(Right Recursion)

--------------------------------

A -> Aab|c|d	(Left Recursion)

A -> cA' | dA'
A'-> abA' | €	(Right Recursion)

--------------------------------

S -> SaS | SbS | c	(Left Recursion)

S -> cS'
S'-> aSS' | bSS' | €	(Right Recursion)

--------------------------------

E -> E + E | E * E  | (E) | id	(Left Recursion)

E -> (E)E' | id E'
E' -> +EE' | *EE' | € 

Ambiguous Grammar:
If a grammar both have left an dright recursion (S -> SaS | B)
(they don't have to be in the same production)

S -> AB
A -> SA | a	(Right Recursion)
				-> Ambiguous
B -> BS | b	(Left Recursion)

Grammar with Common Prefixes:
If the RHS of more than one produtio nstarts with the
same squence of symbols (i.e. S -> ab | abc | ad)

Left Factoring:
The process of removing common prefixes from the grammar

S -> ab | abc | ad	(We take the longest common one so ab)

S -> abS' | ad
S'-> € | c |		(We introduced a new one, but now a is common)

S -> a S''
S'' -> bS' | d
S' -> € | c		(Now there are no common prefixes)

First:
The set of all terminals that may begin in RHS
For example: 	S-> € | a | b First(S): {€,a,b}
		S -> aS | bS | € First(S): {a,b,€}	

If the first part of the production is non-terminal then
it will inherit the first of that non terminal (If it has more
non terminals after it it will inherit all of them).
(S->ABC would inherit First(A,B,C))
For example:
E->TE'	First(E) = {T} -> non terminal so we have to check First(T)
T->FT'	First(T) = {F} -> -"- have to check First(F)
F->(E)|id First(F) = {(,id} -> The First of E,T,F are all {(,id}

Follow:
Follow(A) is the set of all terminals that follow the right of A
(If the LHS is in one of the RHS then the right symbol of the RHS)

S -> a | b | €	Follow(S)= {$} (Dollar is the default)	

S -> Sa | Sb | € Follow(S)= {$,a,b}

LL(1) grammar:
A grammar is LL(1) if the parse table for it doesn't have
multiple entries

Bottom-up parser (shift/reduce parser):
The process of cunstructing the parse tree starting with
the input string and getting the start symbol of the grammar

Top-down parser:
You start with the start symbol then work you way up
to the string

Handle:
Sequence of grammar symbols that match the RHS of any production

Handle pruning:
The process of finding and reducing the handle

Reduce:
Substituting the LHS for one of the production